{"version":3,"sources":["../src/index.ts","index.js"],"names":["cycleDetected","Error","endBatch","batchDepth","error","hasError","batchedEffect","batchIteration","effect","next","_nextBatchedEffect","_flags","needsToRecompute","_callback","err","batch","callback","evalContext","globalVersion","addDependency","signal","node","_node","_target","_version","_source","_prevSource","_sources","_nextSource","_prevTarget","_nextTarget","_rollbackNode","_subscribe","Signal","value","this","_value","_targets","target","_refresh","prepareSources","rollbackNode","cleanupSources","head","prev","_unsubscribe","Computed","compute","call","_compute","_globalVersion","computed","cleanupEffect","cleanup","_cleanup","prevContext","disposeEffect","endEffect","Effect","_dispose","bind","prototype","subscribe","fn","flag","valueOf","toString","toJSON","peek","Object","defineProperty","get","set","_notify","OUTDATED","_node2","finish","_start","require","_signalsCore","_typeof","obj","Symbol","iterator","constructor","_regeneratorRuntime","exports","Op","hasOwn","hasOwnProperty","key","desc","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","makeInvokeMethod","tryCatch","arg","type","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","_invoke","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","record","result","__await","then","unwrapped","state","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","done","methodName","undefined","return","TypeError","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","catch","_catch","thrown","delegateYield","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","apply","tenCentsCard","document","querySelector","twentyCentsCard","fiftyCentsCard","oneDollarCard","twoDollarsCard","fiveDollarsCard","tenDollarsCard","tenCentsCounter","twentyCentsCounter","fiftyCentsCounter","oneDollarCounter","twoDollarsCounter","fiveDollarsCounter","tenDollarsCounter","totalAmount","numberOfCoins","textContent","toastTimer","toast","toastAnimation","animate","bottom","opacity","duration","easing","iterations","cancel","isToastFadingOut","clearTimeout","concat","style","visibility","playbackRate","play","setTimeout","_callee","animationPromise","_callee$","_context","onfinish","counterMappigs","element","counter","_ref2","addEventListener"],"mappings":"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","file":"src.1462d3be.js","sourceRoot":"../../001 - Vanilla JS Coin Counter using Signals/src","sourcesContent":["function cycleDetected(): never {\n\tthrow new Error(\"Cycle detected\");\n}\nfunction mutationDetected(): never {\n\tthrow new Error(\"Computed cannot have side-effects\");\n}\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\nfunction batch<T>(callback: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn callback();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n// @ts-ignore internal Signal is viewed as a function\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore internal Signal is viewed as function\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\tconst signal = this;\n\treturn effect(function (this: Effect) {\n\t\tconst value = signal.value;\n\t\tconst flag = this._flags & TRACKING;\n\t\tthis._flags &= ~TRACKING;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tthis._flags |= flag;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\treturn this._value;\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget() {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (evalContext instanceof Computed) {\n\t\t\tmutationDetected();\n\t\t}\n\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tcycleDetected();\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\nfunction signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_compute: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(compute: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._compute = compute;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._compute();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when the it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nComputed.prototype.peek = function () {\n\tif (!this._refresh()) {\n\t\tcycleDetected();\n\t}\n\tif (this._flags & HAS_ERROR) {\n\t\tthrow this._value;\n\t}\n\treturn this._value;\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget() {\n\t\tif (this._flags & RUNNING) {\n\t\t\tcycleDetected();\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n\treadonly value: T;\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n\treturn new Computed(compute);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._compute = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectCleanup = () => unknown;\ndeclare class Effect {\n\t_compute?: () => unknown | EffectCleanup;\n\t_cleanup?: () => unknown;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(compute: () => unknown | EffectCleanup);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, compute: () => unknown | EffectCleanup) {\n\tthis._compute = compute;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._compute === undefined) return;\n\n\t\tconst cleanup = this._compute();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup as EffectCleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tcycleDetected();\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nfunction effect(compute: () => unknown | EffectCleanup): () => void {\n\tconst effect = new Effect(compute);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport { signal, computed, effect, batch, Signal, type ReadonlySignal };\n","import './styles/index.scss';\nimport { signal, effect, computed } from '@preact/signals-core';\n\nconst tenCentsCard = document.querySelector('#counter-ten-cents');\nconst twentyCentsCard = document.querySelector('#counter-twenty-cents');\nconst fiftyCentsCard = document.querySelector('#counter-fifty-cents');\nconst oneDollarCard = document.querySelector('#counter-one-dollar');\nconst twoDollarsCard = document.querySelector('#counter-two-dollars');\nconst fiveDollarsCard = document.querySelector('#counter-five-dollars');\nconst tenDollarsCard = document.querySelector('#counter-ten-dollars');\n\nconst tenCentsCounter = signal(0);\nconst twentyCentsCounter = signal(0);\nconst fiftyCentsCounter = signal(0);\nconst oneDollarCounter = signal(0);\nconst twoDollarsCounter = signal(0);\nconst fiveDollarsCounter = signal(0);\nconst tenDollarsCounter = signal(0);\n\nconst totalAmount = computed(\n  () => (\n    tenCentsCounter * (0.1 * 10) +\n    twentyCentsCounter * (0.2 * 10) +\n    fiftyCentsCounter * (0.5 * 10) +\n    oneDollarCounter * (1 * 10) +\n    twoDollarsCounter * (2 * 10) +\n    fiveDollarsCounter * (5 * 10) +\n    tenDollarsCounter * (10 * 10)\n  ) / 10\n);\n\nconst numberOfCoins = computed(\n  () => (\n    tenCentsCounter +\n    twentyCentsCounter +\n    fiftyCentsCounter +\n    oneDollarCounter +\n    twoDollarsCounter +\n    fiveDollarsCounter +\n    tenDollarsCounter\n  )\n);\n\neffect(() => {\n  tenCentsCard.querySelector('.quantity').textContent = tenCentsCounter.value;\n});\n\neffect(() => {\n  twentyCentsCard.querySelector('.quantity').textContent = twentyCentsCounter.value;\n});\n\neffect(() => {\n  fiftyCentsCard.querySelector('.quantity').textContent = fiftyCentsCounter.value;\n});\n\neffect(() => {\n  oneDollarCard.querySelector('.quantity').textContent = oneDollarCounter.value;\n});\n\neffect(() => {\n  twoDollarsCard.querySelector('.quantity').textContent = twoDollarsCounter.value;\n});\n\neffect(() => {\n  fiveDollarsCard.querySelector('.quantity').textContent = fiveDollarsCounter.value;\n});\n\neffect(() => {\n  tenDollarsCard.querySelector('.quantity').textContent = tenDollarsCounter.value;\n});\n\n\nconst toast = document.querySelector('.toast');\nconst toastAnimation = toast.animate(\n  [\n    {bottom: 0, opacity: 0},\n    {bottom: '1.5rem', opacity: 1},\n  ],\n  {\n    duration: 300,\n    easing: 'ease-in-out',\n    iterations: 1\n  }\n);\n\ntoastAnimation.cancel();\n\nlet toastTimer;\nlet isToastFadingOut = false;\n\neffect(() => {\n  clearTimeout(toastTimer);\n\n  toast.textContent = `You have ${numberOfCoins} coins with a total value of HK$${totalAmount}`;\n\n  if (isToastFadingOut) {\n    toastAnimation.cancel();\n    isToastFadingOut = false;\n  }\n\n  if (toast.style.visibility !== 'visible' || isToastFadingOut) {\n    toastAnimation.playbackRate = 1;\n    toastAnimation.play();\n  }\n\n  toast.style.visibility = 'visible';\n\n  toastTimer = setTimeout(async () => {\n    isToastFadingOut = true;\n    const animationPromise = new Promise((resolve) => {\n      toastAnimation.onfinish = resolve;\n    });\n\n    toastAnimation.playbackRate = -1;\n    toastAnimation.play();\n    await animationPromise;\n\n    toast.style.visibility = 'hidden';\n    isToastFadingOut = false;\n  }, 2000);\n});\n\nconst counterMappigs = [\n  { element: tenCentsCard, counter: tenCentsCounter },\n  { element: twentyCentsCard, counter: twentyCentsCounter },\n  { element: fiftyCentsCard, counter: fiftyCentsCounter },\n  { element: oneDollarCard, counter: oneDollarCounter },\n  { element: twoDollarsCard, counter: twoDollarsCounter },\n  { element: fiveDollarsCard, counter: fiveDollarsCounter },\n  { element: tenDollarsCard, counter: tenDollarsCounter }\n];\n\ncounterMappigs.forEach(({ element, counter }) => {\n  element.querySelector('.plus-button').addEventListener('click', () => {\n    counter.value++;\n  });\n\n  element.querySelector('.minus-button').addEventListener('click', () => {\n    if (counter.value > 0) {\n      counter.value--;\n    }\n  });\n});\n"]}