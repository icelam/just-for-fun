{"mappings":"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","sources":["<anon>","src/index.ts"],"sourcesContent":["var $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequiree857\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequiree857\"] = parcelRequire;\n}\nparcelRequire.register(\"kOHZq\", function(module, exports) {\nvar _a;\nvar ScratchCanvas = /** @class */ function() {\n    function ScratchCanvas(canvasSelector, resetButtonSelector, fillColor) {\n        this.isDrawing = false;\n        this.canvas = canvasSelector ? document.querySelector(canvasSelector) : null;\n        this.resetButton = resetButtonSelector ? document.querySelector(resetButtonSelector) : null;\n        this.removableLayerColor = fillColor;\n        if (!this.canvas) throw new Error(\"NULLISH_CANVAS\");\n        this.context = this.canvas.getContext(\"2d\");\n        this.canvasWidth = this.canvas.width;\n        this.canvasHeight = this.canvas.height;\n    }\n    /* Get mouse pointer position */ ScratchCanvas.prototype.getMousePosition = function(event) {\n        var rect = this.canvas.getBoundingClientRect();\n        var x = event.clientX - rect.left;\n        var y = event.clientY - rect.top;\n        return {\n            x: x,\n            y: y\n        };\n    };\n    /* Get mobile touch position */ ScratchCanvas.prototype.getTouchPosition = function(event) {\n        var rootElem = document.documentElement;\n        var rect = this.canvas.getBoundingClientRect();\n        var top = rect.top + window.pageYOffset - rootElem.clientTop;\n        var left = rect.left + window.pageXOffset - rootElem.clientLeft;\n        var touch = event.targetTouches[0] || event.changedTouches[0];\n        var touchX = touch.pageX - left;\n        var touchY = touch.pageY - top;\n        return {\n            touchX: touchX,\n            touchY: touchY\n        };\n    };\n    /* Mouse Down function */ ScratchCanvas.prototype.canvasMouseDown = function(event) {\n        this.isDrawing = true;\n        var _a = this.getMousePosition(event), x = _a.x, y = _a.y;\n        this.context.beginPath();\n        this.context.moveTo(x, y);\n    };\n    /* Mouse Move function */ ScratchCanvas.prototype.canvasMouseMove = function(event) {\n        if (this.isDrawing) {\n            var _a = this.getMousePosition(event), x = _a.x, y = _a.y;\n            this.context.lineTo(x, y);\n            this.context.stroke();\n        }\n    };\n    /* Mouse Up function */ ScratchCanvas.prototype.canvasMouseUp = function(event) {\n        if (this.isDrawing) {\n            var _a = this.getMousePosition(event), x = _a.x, y = _a.y;\n            this.context.lineTo(x, y);\n            this.context.stroke();\n            this.isDrawing = false;\n        }\n    };\n    /* Touch Start function */ ScratchCanvas.prototype.canvasTouchStart = function(event) {\n        event.preventDefault();\n        if (!this.isDrawing) {\n            // Reset status\n            this.isDrawing = true;\n            var _a = this.getTouchPosition(event), touchX = _a.touchX, touchY = _a.touchY;\n            this.context.beginPath();\n            this.context.moveTo(touchX, touchY);\n        }\n    };\n    /* Touch Move function */ ScratchCanvas.prototype.canvasTouchMove = function(event) {\n        event.preventDefault();\n        if (this.isDrawing) {\n            var _a = this.getTouchPosition(event), touchX = _a.touchX, touchY = _a.touchY;\n            this.context.lineTo(touchX, touchY);\n            this.context.stroke();\n        }\n    };\n    /* Touch End function */ ScratchCanvas.prototype.canvasTouchEnd = function(event) {\n        // End Drawing\n        var _a = this.getTouchPosition(event), touchX = _a.touchX, touchY = _a.touchY;\n        this.context.lineTo(touchX, touchY);\n        this.context.stroke();\n        this.isDrawing = false;\n    };\n    /* Fill canvas with removable layer */ ScratchCanvas.prototype.addRemovableLayer = function() {\n        this.context.globalCompositeOperation = \"source-over\";\n        this.context.fillStyle = this.removableLayerColor;\n        this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n        this.context.globalCompositeOperation = \"destination-out\";\n    };\n    /* Init */ ScratchCanvas.prototype.init = function() {\n        var _this = this;\n        if (!this.context) throw new Error(\"NULLISH_CONTEXT\");\n        this.context.lineCap = \"round\";\n        this.context.lineJoin = \"round\";\n        this.context.lineWidth = 30;\n        this.context.strokeStyle = \"#000000\";\n        this.addRemovableLayer();\n        // Listeners - mouse pointer\n        // 'mousemove' and 'mouseup' is attached to window instead of canvas\n        // to properly end drawing when mouse releases outside of canvas\n        var onMouseDown = function(event) {\n            _this.canvasMouseDown(event);\n        };\n        var onMouseMove = function(event) {\n            _this.canvasMouseMove(event);\n        };\n        var onMouseUp = function(event) {\n            _this.canvasMouseUp(event);\n        };\n        this.canvas.addEventListener(\"mousedown\", onMouseDown);\n        window.addEventListener(\"mousemove\", onMouseMove);\n        window.addEventListener(\"mouseup\", onMouseUp);\n        // Listeners - touch devices\n        var onTouchStart = function(event) {\n            _this.canvasTouchStart(event);\n        };\n        var onTouchMove = function(event) {\n            _this.canvasTouchMove(event);\n        };\n        var onTouchEnd = function(event) {\n            _this.canvasTouchEnd(event);\n        };\n        this.canvas.addEventListener(\"touchstart\", onTouchStart);\n        this.canvas.addEventListener(\"touchmove\", onTouchMove);\n        this.canvas.addEventListener(\"touchend\", onTouchEnd);\n        // Reset scratch area\n        var onReset = function(event) {\n            _this.addRemovableLayer();\n        };\n        this.resetButton.addEventListener(\"click\", onReset);\n    };\n    return ScratchCanvas;\n}();\n// Parcel has duplicate events attached when hot reload\n// This workaround is suggested by the official member:\n// https://github.com/parcel-bundler/parcel/issues/1718#issuecomment-404608947\n(_a = module === null || module === void 0 ? void 0 : module.hot) === null || _a === void 0 || _a.dispose(function() {\n    window.location.reload();\n});\nvar LotteryScratchCanvas = new ScratchCanvas(\"#scratch-canvas\", \"#scratch-reset-button\", \"#B7B7B7\");\nLotteryScratchCanvas.init();\n\n});\n\n\nparcelRequire(\"kOHZq\");\n\n//# sourceMappingURL=index.a6874987.js.map\n","type Maybe<T> = T | undefined | null;\n\nclass ScratchCanvas {\n  private canvas: HTMLCanvasElement | null;\n  private context: Maybe<CanvasRenderingContext2D>;\n  private canvasWidth: number;\n  private canvasHeight: number;\n  private removableLayerColor: string;\n  private isDrawing = false;\n  private resetButton: HTMLButtonElement | null;\n\n  constructor(\n    canvasSelector: string,\n    resetButtonSelector: string,\n    fillColor: string,\n  ) {\n    this.canvas = canvasSelector\n      ? document.querySelector(canvasSelector)\n      : null;\n    this.resetButton = resetButtonSelector\n      ? document.querySelector(resetButtonSelector)\n      : null;\n    this.removableLayerColor = fillColor;\n\n    if (!this.canvas) {\n      throw new Error('NULLISH_CANVAS');\n    }\n\n    this.context = this.canvas.getContext('2d');\n    this.canvasWidth = this.canvas.width;\n    this.canvasHeight = this.canvas.height;\n  }\n\n  /* Get mouse pointer position */\n  private getMousePosition(event: MouseEvent) {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n\n    return { x, y };\n  }\n\n  /* Get mobile touch position */\n  private getTouchPosition(event: TouchEvent) {\n    const rootElem = document.documentElement;\n    const rect = this.canvas.getBoundingClientRect();\n\n    const top = rect.top + window.pageYOffset - rootElem.clientTop;\n    const left = rect.left + window.pageXOffset - rootElem.clientLeft;\n\n    const touch = event.targetTouches[0] || event.changedTouches[0];\n    const touchX = touch.pageX - left;\n    const touchY = touch.pageY - top;\n\n    return { touchX, touchY };\n  }\n\n  /* Mouse Down function */\n  private canvasMouseDown(event: MouseEvent) {\n    this.isDrawing = true;\n    const { x, y } = this.getMousePosition(event);\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n  }\n\n  /* Mouse Move function */\n  private canvasMouseMove(event: MouseEvent) {\n    if (this.isDrawing) {\n      const { x, y } = this.getMousePosition(event);\n      this.context.lineTo(x, y);\n      this.context.stroke();\n    }\n  }\n\n  /* Mouse Up function */\n  private canvasMouseUp(event: MouseEvent) {\n    if (this.isDrawing) {\n      const { x, y } = this.getMousePosition(event);\n      this.context.lineTo(x, y);\n      this.context.stroke();\n      this.isDrawing = false;\n    }\n  }\n\n  /* Touch Start function */\n  private canvasTouchStart(event: TouchEvent) {\n    event.preventDefault();\n\n    if (!this.isDrawing) {\n      // Reset status\n      this.isDrawing = true;\n      const { touchX, touchY } = this.getTouchPosition(event);\n      this.context.beginPath();\n      this.context.moveTo(touchX, touchY);\n    }\n  }\n\n  /* Touch Move function */\n  private canvasTouchMove(event: TouchEvent) {\n    event.preventDefault();\n\n    if (this.isDrawing) {\n      const { touchX, touchY } = this.getTouchPosition(event);\n      this.context.lineTo(touchX, touchY);\n      this.context.stroke();\n    }\n  }\n\n  /* Touch End function */\n  private canvasTouchEnd(event: TouchEvent) {\n    // End Drawing\n    const { touchX, touchY } = this.getTouchPosition(event);\n    this.context.lineTo(touchX, touchY);\n    this.context.stroke();\n    this.isDrawing = false;\n  }\n\n  /* Fill canvas with removable layer */\n\n  addRemovableLayer() {\n    this.context.globalCompositeOperation = 'source-over';\n    this.context.fillStyle = this.removableLayerColor;\n    this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n    this.context.globalCompositeOperation = 'destination-out';\n  }\n\n  /* Init */\n  init() {\n    if (!this.context) {\n      throw new Error('NULLISH_CONTEXT');\n    }\n\n    this.context.lineCap = 'round';\n    this.context.lineJoin = 'round';\n    this.context.lineWidth = 30;\n    this.context.strokeStyle = '#000000';\n    this.addRemovableLayer();\n\n    // Listeners - mouse pointer\n    // 'mousemove' and 'mouseup' is attached to window instead of canvas\n    // to properly end drawing when mouse releases outside of canvas\n    const onMouseDown = (event: MouseEvent) => {\n      this.canvasMouseDown(event);\n    };\n\n    const onMouseMove = (event: MouseEvent) => {\n      this.canvasMouseMove(event);\n    };\n\n    const onMouseUp = (event: MouseEvent) => {\n      this.canvasMouseUp(event);\n    };\n\n    this.canvas.addEventListener('mousedown', onMouseDown);\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n\n    // Listeners - touch devices\n    const onTouchStart = (event: TouchEvent) => {\n      this.canvasTouchStart(event);\n    };\n\n    const onTouchMove = (event: TouchEvent) => {\n      this.canvasTouchMove(event);\n    };\n\n    const onTouchEnd = (event: TouchEvent) => {\n      this.canvasTouchEnd(event);\n    };\n\n    this.canvas.addEventListener('touchstart', onTouchStart);\n    this.canvas.addEventListener('touchmove', onTouchMove);\n    this.canvas.addEventListener('touchend', onTouchEnd);\n\n    // Reset scratch area\n    const onReset = (event: MouseEvent) => {\n      this.addRemovableLayer();\n    };\n\n    this.resetButton.addEventListener('click', onReset);\n  }\n}\n\n// Parcel has duplicate events attached when hot reload\n// This workaround is suggested by the official member:\n// https://github.com/parcel-bundler/parcel/issues/1718#issuecomment-404608947\nmodule?.hot?.dispose(() => {\n  window.location.reload();\n});\n\nconst LotteryScratchCanvas = new ScratchCanvas(\n  '#scratch-canvas',\n  '#scratch-reset-button',\n  '#B7B7B7',\n);\n\nLotteryScratchCanvas.init();\n"],"names":["$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","_a","ScratchCanvas","canvasSelector","resetButtonSelector","fillColor","isDrawing","canvas","document","querySelector","resetButton","removableLayerColor","context","getContext","canvasWidth","width","canvasHeight","height","prototype","getMousePosition","event","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","getTouchPosition","rootElem","documentElement","pageYOffset","clientTop","pageXOffset","clientLeft","touch","targetTouches","changedTouches","touchX","pageX","touchY","pageY","canvasMouseDown","beginPath","moveTo","canvasMouseMove","lineTo","stroke","canvasMouseUp","canvasTouchStart","preventDefault","canvasTouchMove","canvasTouchEnd","addRemovableLayer","globalCompositeOperation","fillStyle","fillRect","_this","lineCap","lineJoin","lineWidth","strokeStyle","addEventListener","hot","dispose","location","reload","LotteryScratchCanvas"],"version":3,"file":"index.a6874987.js.map"}