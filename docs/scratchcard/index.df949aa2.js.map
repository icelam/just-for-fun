{"mappings":"A,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,Q,S,C,C,C,E,a,I,E,E,I,E,I,C,S,E,S,C,C,C,C,C,C,C,E,O,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,E,C,C,S,E,C,M,C,C,E,I,C,E,E,K,E,A,C,C,E,E,K,Y,E,E,I,E,S,C,E,E,E,E,E,I,C,E,E,C,E,A,C,E,E,K,C,E,G,E,C,E,I,G,E,E,E,I,E,I,C,W,E,S,C,C,C,E,I,E,E,E,E,E,C,M,E,K,W,G,A,E,C,C,E,C,M,C,C,E,C,O,C,C,E,A,E,K,E,C,I,E,A,E,O,E,C,K,E,G,M,E,G,O,E,E,E,A,Y,O,Q,C,C,C,O,Q,C,C,W,O,I,A,C,E,E,S,E,C,E,O,S,C,E,O,A,S,C,E,G,E,M,A,U,mC,K,G,C,E,E,C,C,E,E,C,E,C,C,E,G,G,C,G,E,E,G,C,E,A,E,C,C,E,C,E,M,C,C,C,E,C,E,K,E,C,A,C,E,E,M,A,G,E,I,C,G,C,E,E,I,A,G,C,A,C,E,E,I,C,E,C,C,E,C,E,I,C,O,E,O,E,E,A,G,C,E,C,A,E,C,C,E,C,E,K,C,A,E,C,C,E,E,K,E,K,E,E,E,K,M,E,O,E,K,G,C,M,C,C,E,C,K,C,C,C,M,E,E,K,G,E,C,C,E,C,E,C,E,C,Q,M,E,E,E,G,C,G,G,E,I,C,G,G,Q,S,G,C,C,E,A,C,E,E,I,A,E,M,C,G,C,C,E,M,C,E,A,G,C,A,I,C,C,E,E,A,I,C,C,E,A,E,C,E,E,Q,C,G,A,I,C,C,E,E,C,C,G,C,C,E,C,C,C,E,E,C,C,E,C,C,C,E,A,E,C,E,K,C,C,C,E,C,K,C,G,A,I,C,C,E,E,E,K,C,C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","sources":["<anon>","src/index.ts"],"sourcesContent":["var $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequiree857\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequiree857\"] = parcelRequire;\n}\nparcelRequire.register(\"kOHZq\", function(module, exports) {\n\"use strict\";\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = this && this.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar _a;\nvar ScratchCanvas = /** @class */ function() {\n    function ScratchCanvas(canvasSelector, prizeTextSelector, resetButtonSelector, fillColor) {\n        /** Whether user is interacting with canvas */ this.isDrawing = false;\n        /** Debounce duration for checking whether prize text is visible */ this.checkDebounceDuration = 100;\n        /** Has user won the prize */ this.hasWon = false;\n        var canvasElement = canvasSelector ? document.querySelector(canvasSelector) : null;\n        var prizeTextElement = prizeTextSelector ? document.querySelector(prizeTextSelector) : null;\n        var resetButtonElement = resetButtonSelector ? document.querySelector(resetButtonSelector) : null;\n        if (!canvasElement) throw new Error(\"NULLISH_CANVAS\");\n        if (!prizeTextElement) throw new Error(\"NULLISH_PRIZE_TEXT\");\n        if (!resetButtonElement) throw new Error(\"NULLISH_RESET_BUTTON\");\n        this.canvas = canvasElement;\n        this.prizeText = prizeTextElement;\n        this.resetButton = resetButtonElement;\n        var context = this.canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        if (!context) throw new Error(\"NULLISH_CONTEXT\");\n        this.context = context;\n        this.canvasWidth = this.canvas.width;\n        this.canvasHeight = this.canvas.height;\n        this.removableLayerColor = fillColor;\n        this.canvasAnimation = this.canvas.animate([\n            {\n                opacity: \"1\"\n            },\n            {\n                opacity: \"0\"\n            }\n        ], {\n            duration: 200,\n            easing: \"ease-in-out\",\n            iterations: 1,\n            fill: \"forwards\"\n        });\n        this.canvasAnimation.cancel();\n        this.prizeTextAnimation = this.prizeText.animate([\n            {\n                transform: \"none\"\n            },\n            {\n                transform: \"scale(1.125)\"\n            },\n            {\n                transform: \"none\"\n            }\n        ], {\n            duration: 600,\n            easing: \"ease-in-out\",\n            iterations: 1,\n            fill: \"forwards\"\n        });\n        this.prizeTextAnimation.cancel();\n    }\n    /** Get mouse pointer position */ ScratchCanvas.prototype.getMousePosition = function(event) {\n        var rect = this.canvas.getBoundingClientRect();\n        var x = event.clientX - rect.left;\n        var y = event.clientY - rect.top;\n        return {\n            x: x,\n            y: y\n        };\n    };\n    /** Get mobile touch position */ ScratchCanvas.prototype.getTouchPosition = function(event) {\n        var rootElem = document.documentElement;\n        var rect = this.canvas.getBoundingClientRect();\n        var top = rect.top + window.pageYOffset - rootElem.clientTop;\n        var left = rect.left + window.pageXOffset - rootElem.clientLeft;\n        var touch = event.targetTouches[0] || event.changedTouches[0];\n        var touchX = touch.pageX - left;\n        var touchY = touch.pageY - top;\n        return {\n            touchX: touchX,\n            touchY: touchY\n        };\n    };\n    /** Mouse Down function */ ScratchCanvas.prototype.canvasMouseDown = function(event) {\n        this.isDrawing = true;\n        var _a = this.getMousePosition(event), x = _a.x, y = _a.y;\n        this.context.beginPath();\n        this.context.moveTo(x, y);\n    };\n    /** Mouse Move function */ ScratchCanvas.prototype.canvasMouseMove = function(event) {\n        if (this.isDrawing) {\n            var _a = this.getMousePosition(event), x = _a.x, y = _a.y;\n            this.context.lineTo(x, y);\n            this.context.stroke();\n        }\n    };\n    /**\n     * Mouse Up function\n     * @returns {boolean} Whether draw is ended base on original drawing state.\n     */ ScratchCanvas.prototype.canvasMouseUp = function(event) {\n        if (this.isDrawing) {\n            var _a = this.getMousePosition(event), x = _a.x, y = _a.y;\n            this.context.lineTo(x, y);\n            this.context.stroke();\n            this.isDrawing = false;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Touch Start function\n     * @returns {boolean} Whether draw is started base on original drawing state.\n     */ ScratchCanvas.prototype.canvasTouchStart = function(event) {\n        event.preventDefault();\n        if (!this.isDrawing) {\n            // Reset status\n            this.isDrawing = true;\n            var _a = this.getTouchPosition(event), touchX = _a.touchX, touchY = _a.touchY;\n            this.context.beginPath();\n            this.context.moveTo(touchX, touchY);\n            return true;\n        }\n        return false;\n    };\n    /** Touch Move function */ ScratchCanvas.prototype.canvasTouchMove = function(event) {\n        event.preventDefault();\n        if (this.isDrawing) {\n            var _a = this.getTouchPosition(event), touchX = _a.touchX, touchY = _a.touchY;\n            this.context.lineTo(touchX, touchY);\n            this.context.stroke();\n        }\n    };\n    /** Touch End function */ ScratchCanvas.prototype.canvasTouchEnd = function(event) {\n        // End Drawing\n        var _a = this.getTouchPosition(event), touchX = _a.touchX, touchY = _a.touchY;\n        this.context.lineTo(touchX, touchY);\n        this.context.stroke();\n        this.isDrawing = false;\n    };\n    /** Fill canvas with removable layer */ ScratchCanvas.prototype.addRemovableLayer = function() {\n        this.context.globalCompositeOperation = \"source-over\";\n        this.context.fillStyle = this.removableLayerColor;\n        this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n        this.context.globalCompositeOperation = \"destination-out\";\n    };\n    /**\n     * Determine if percentage of transparent pixels (black filled area) overlaping with prize text\n     * is greater than 80% or not\n     */ ScratchCanvas.prototype.isPrizeTextVisible = function() {\n        // Get width and height of prize text here instead of caching when constructor is loaded as\n        // CSS might not be completely rendered at that time...\n        // FIXME: call init() only when we know CSS is loaded and rendered\n        var prizeTextWidth = this.prizeText.clientWidth;\n        var prizeTextHeight = this.prizeText.clientHeight;\n        var imageData = this.context.getImageData((this.canvasWidth - prizeTextWidth) / 2, (this.canvasHeight - prizeTextHeight) / 2, prizeTextWidth, prizeTextHeight);\n        var pixelData = imageData.data;\n        var transparentPixelCount = 0;\n        for(var i = 0; i < pixelData.length; i += 4){\n            var red = pixelData[i];\n            var green = pixelData[i + 1];\n            var blue = pixelData[i + 2];\n            var alpha = pixelData[i + 3];\n            if (red === 0 && green === 0 && blue === 0 && alpha === 0) transparentPixelCount++;\n        }\n        var transparentAreaPercentage = transparentPixelCount * 100 / (prizeTextWidth * prizeTextHeight);\n        return transparentAreaPercentage >= 90;\n    };\n    /**\n     * Show winning animation which applies:\n     * 1. Pop-out effect to prize text\n     * 2. Fade out effect to removable layer, which is the canvas itself\n     */ ScratchCanvas.prototype.showWinningAnimation = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                if (this.hasWon) return [\n                    2 /*return*/ \n                ];\n                this.hasWon = true;\n                this.canvasAnimation.play();\n                this.prizeTextAnimation.play();\n                return [\n                    2 /*return*/ \n                ];\n            });\n        });\n    };\n    /** Function to reset all winning state and animation and reset canvas */ ScratchCanvas.prototype.reset = function() {\n        this.canvasAnimation.cancel();\n        this.prizeTextAnimation.cancel();\n        this.addRemovableLayer();\n        this.hasWon = false;\n    };\n    /** Initialize by attaching various event listeners to support interaction with canvas */ ScratchCanvas.prototype.init = function() {\n        var _this = this;\n        this.context.lineCap = \"round\";\n        this.context.lineJoin = \"round\";\n        this.context.lineWidth = 30;\n        this.context.strokeStyle = \"#000000\";\n        this.addRemovableLayer();\n        var prizeTextVisibleCheckTimer = undefined;\n        // Listeners - mouse pointer\n        // 'mousemove' and 'mouseup' is attached to window instead of canvas\n        // to properly end drawing when mouse releases outside of canvas\n        var onMouseDown = function(event) {\n            // window.clearTimeout(prizeTextVisibleCheckTimer);\n            _this.canvasMouseDown(event);\n        };\n        var onMouseMove = function(event) {\n            _this.canvasMouseMove(event);\n        };\n        var onMouseUp = function(event) {\n            var wasDrawing = _this.canvasMouseUp(event);\n            if (wasDrawing) // Add a resonable delay so that we do not trigger heavy canvas data check operation too frequently.\n            // window.clearTimeout(prizeTextVisibleCheckTimer);\n            // prizeTextVisibleCheckTimer = window.setTimeout(() => {\n            {\n                if (_this.isPrizeTextVisible()) _this.showWinningAnimation();\n            }\n        };\n        this.canvas.addEventListener(\"mousedown\", onMouseDown);\n        window.addEventListener(\"mousemove\", onMouseMove);\n        window.addEventListener(\"mouseup\", onMouseUp);\n        // Listeners - touch devices\n        var onTouchStart = function(event) {\n            window.clearTimeout(prizeTextVisibleCheckTimer);\n            _this.canvasTouchStart(event);\n        };\n        var onTouchMove = function(event) {\n            _this.canvasTouchMove(event);\n        };\n        var onTouchEnd = function(event) {\n            _this.canvasTouchEnd(event);\n            window.clearTimeout(prizeTextVisibleCheckTimer);\n            prizeTextVisibleCheckTimer = window.setTimeout(function() {\n                if (_this.isPrizeTextVisible()) _this.showWinningAnimation();\n            }, _this.checkDebounceDuration);\n        };\n        this.canvas.addEventListener(\"touchstart\", onTouchStart);\n        this.canvas.addEventListener(\"touchmove\", onTouchMove);\n        this.canvas.addEventListener(\"touchend\", onTouchEnd);\n        this.resetButton.addEventListener(\"click\", this.reset.bind(this));\n    };\n    return ScratchCanvas;\n}();\n// Parcel has duplicate events attached when hot reload\n// This workaround is suggested by the official member:\n// https://github.com/parcel-bundler/parcel/issues/1718#issuecomment-404608947\n// @ts-expect-error - `hot` is not defined in node's type definition\n(_a = module === null || module === void 0 ? void 0 : module.hot) === null || _a === void 0 || _a.dispose(function() {\n    window.location.reload();\n});\nvar LotteryScratchCanvas = new ScratchCanvas(\"#scratch-canvas\", \"#prize-text\", \"#scratch-reset-button\", \"#B7B7B7\");\nLotteryScratchCanvas.init();\n\n});\n\n\nparcelRequire(\"kOHZq\");\n\n//# sourceMappingURL=index.df949aa2.js.map\n","class ScratchCanvas {\n  /** Canvas element */\n  private canvas: HTMLCanvasElement;\n  /** Web animation of canvas */\n  private canvasAnimation: Animation;\n  /** Canvas context */\n  private context: CanvasRenderingContext2D;\n  /** Width of canvas */\n  private canvasWidth: number;\n  /** Height of canvas */\n  private canvasHeight: number;\n  /** Fill color of removable layer */\n  private removableLayerColor: string;\n  /** Whether user is interacting with canvas */\n  private isDrawing = false;\n  /** Prize text element */\n  private prizeText: HTMLSpanElement;\n  /** Web animation of prize text */\n  private prizeTextAnimation: Animation;\n  /** Reset button element */\n  private resetButton: HTMLButtonElement;\n  /** Debounce duration for checking whether prize text is visible */\n  private checkDebounceDuration = 100;\n  /** Has user won the prize */\n  private hasWon = false;\n\n  constructor(\n    canvasSelector: string,\n    prizeTextSelector: string,\n    resetButtonSelector: string,\n    fillColor: string,\n  ) {\n    const canvasElement = canvasSelector\n      ? document.querySelector<HTMLCanvasElement>(canvasSelector)\n      : null;\n    const prizeTextElement = prizeTextSelector\n      ? document.querySelector<HTMLSpanElement>(prizeTextSelector)\n      : null;\n    const resetButtonElement = resetButtonSelector\n      ? document.querySelector<HTMLButtonElement>(resetButtonSelector)\n      : null;\n\n    if (!canvasElement) {\n      throw new Error('NULLISH_CANVAS');\n    }\n\n    if (!prizeTextElement) {\n      throw new Error('NULLISH_PRIZE_TEXT');\n    }\n\n    if (!resetButtonElement) {\n      throw new Error('NULLISH_RESET_BUTTON');\n    }\n\n    this.canvas = canvasElement;\n    this.prizeText = prizeTextElement;\n    this.resetButton = resetButtonElement;\n\n    const context = this.canvas.getContext('2d', { willReadFrequently: true });\n\n    if (!context) {\n      throw new Error('NULLISH_CONTEXT');\n    }\n\n    this.context = context;\n    this.canvasWidth = this.canvas.width;\n    this.canvasHeight = this.canvas.height;\n    this.removableLayerColor = fillColor;\n\n    this.canvasAnimation = this.canvas.animate(\n      [\n        { opacity: '1' },\n        { opacity: '0' },\n      ],\n      {\n        duration: 200,\n        easing: 'ease-in-out',\n        iterations: 1,\n        fill: 'forwards',\n      },\n    );\n\n    this.canvasAnimation.cancel();\n\n    this.prizeTextAnimation = this.prizeText.animate(\n      [\n        { transform: 'none' },\n        { transform: 'scale(1.125)' },\n        { transform: 'none' },\n      ],\n      {\n        duration: 600,\n        easing: 'ease-in-out',\n        iterations: 1,\n        fill: 'forwards',\n      },\n    );\n\n    this.prizeTextAnimation.cancel();\n  }\n\n  /** Get mouse pointer position */\n  private getMousePosition(event: MouseEvent) {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n\n    return { x, y };\n  }\n\n  /** Get mobile touch position */\n  private getTouchPosition(event: TouchEvent) {\n    const rootElem = document.documentElement;\n    const rect = this.canvas.getBoundingClientRect();\n\n    const top = rect.top + window.pageYOffset - rootElem.clientTop;\n    const left = rect.left + window.pageXOffset - rootElem.clientLeft;\n\n    const touch = event.targetTouches[0] || event.changedTouches[0];\n    const touchX = touch.pageX - left;\n    const touchY = touch.pageY - top;\n\n    return { touchX, touchY };\n  }\n\n  /** Mouse Down function */\n  private canvasMouseDown(event: MouseEvent) {\n    this.isDrawing = true;\n    const { x, y } = this.getMousePosition(event);\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n  }\n\n  /** Mouse Move function */\n  private canvasMouseMove(event: MouseEvent) {\n    if (this.isDrawing) {\n      const { x, y } = this.getMousePosition(event);\n      this.context.lineTo(x, y);\n      this.context.stroke();\n    }\n  }\n\n  /**\n   * Mouse Up function\n   * @returns {boolean} Whether draw is ended base on original drawing state.\n   */\n  private canvasMouseUp(event: MouseEvent): boolean {\n    if (this.isDrawing) {\n      const { x, y } = this.getMousePosition(event);\n      this.context.lineTo(x, y);\n      this.context.stroke();\n      this.isDrawing = false;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Touch Start function\n   * @returns {boolean} Whether draw is started base on original drawing state.\n   */\n  private canvasTouchStart(event: TouchEvent) {\n    event.preventDefault();\n\n    if (!this.isDrawing) {\n      // Reset status\n      this.isDrawing = true;\n      const { touchX, touchY } = this.getTouchPosition(event);\n      this.context.beginPath();\n      this.context.moveTo(touchX, touchY);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /** Touch Move function */\n  private canvasTouchMove(event: TouchEvent) {\n    event.preventDefault();\n\n    if (this.isDrawing) {\n      const { touchX, touchY } = this.getTouchPosition(event);\n      this.context.lineTo(touchX, touchY);\n      this.context.stroke();\n    }\n  }\n\n  /** Touch End function */\n  private canvasTouchEnd(event: TouchEvent) {\n    // End Drawing\n    const { touchX, touchY } = this.getTouchPosition(event);\n    this.context.lineTo(touchX, touchY);\n    this.context.stroke();\n    this.isDrawing = false;\n  }\n\n  /** Fill canvas with removable layer */\n  addRemovableLayer() {\n    this.context.globalCompositeOperation = 'source-over';\n    this.context.fillStyle = this.removableLayerColor;\n    this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n    this.context.globalCompositeOperation = 'destination-out';\n  }\n\n  /**\n   * Determine if percentage of transparent pixels (black filled area) overlaping with prize text\n   * is greater than 80% or not\n   */\n  isPrizeTextVisible() {\n    // Get width and height of prize text here instead of caching when constructor is loaded as\n    // CSS might not be completely rendered at that time...\n    // FIXME: call init() only when we know CSS is loaded and rendered\n    const prizeTextWidth = this.prizeText.clientWidth;\n    const prizeTextHeight = this.prizeText.clientHeight;\n\n    const imageData = this.context.getImageData(\n      (this.canvasWidth - prizeTextWidth) / 2,\n      (this.canvasHeight - prizeTextHeight) / 2,\n      prizeTextWidth,\n      prizeTextHeight,\n    );\n    const pixelData = imageData.data;\n\n    let transparentPixelCount = 0;\n\n    for (let i = 0; i < pixelData.length; i += 4) {\n      const red = pixelData[i];\n      const green = pixelData[i + 1];\n      const blue = pixelData[i + 2];\n      const alpha = pixelData[i + 3];\n\n      if (red === 0 && green === 0 && blue === 0 && alpha === 0) {\n        transparentPixelCount++;\n      }\n    }\n\n    const transparentAreaPercentage = transparentPixelCount * 100 / (prizeTextWidth * prizeTextHeight);\n    return transparentAreaPercentage >= 90;\n  }\n\n  /**\n   * Show winning animation which applies:\n   * 1. Pop-out effect to prize text\n   * 2. Fade out effect to removable layer, which is the canvas itself\n   */\n  async showWinningAnimation() {\n    if (this.hasWon) {\n      return;\n    }\n\n    this.hasWon = true;\n    this.canvasAnimation.play();\n    this.prizeTextAnimation.play();\n  }\n\n  /** Function to reset all winning state and animation and reset canvas */\n  reset() {\n    this.canvasAnimation.cancel();\n    this.prizeTextAnimation.cancel();\n    this.addRemovableLayer();\n    this.hasWon = false;\n  }\n\n  /** Initialize by attaching various event listeners to support interaction with canvas */\n  init() {\n    this.context.lineCap = 'round';\n    this.context.lineJoin = 'round';\n    this.context.lineWidth = 30;\n    this.context.strokeStyle = '#000000';\n    this.addRemovableLayer();\n\n    let prizeTextVisibleCheckTimer: number | undefined = undefined;\n\n    // Listeners - mouse pointer\n    // 'mousemove' and 'mouseup' is attached to window instead of canvas\n    // to properly end drawing when mouse releases outside of canvas\n    const onMouseDown = (event: MouseEvent) => {\n      // window.clearTimeout(prizeTextVisibleCheckTimer);\n      this.canvasMouseDown(event);\n    };\n\n    const onMouseMove = (event: MouseEvent) => {\n      this.canvasMouseMove(event);\n    };\n\n    const onMouseUp = (event: MouseEvent) => {\n      const wasDrawing = this.canvasMouseUp(event);\n\n      if (wasDrawing) {\n        // Add a resonable delay so that we do not trigger heavy canvas data check operation too frequently.\n        // window.clearTimeout(prizeTextVisibleCheckTimer);\n        // prizeTextVisibleCheckTimer = window.setTimeout(() => {\n          if (this.isPrizeTextVisible()) {\n            this.showWinningAnimation();\n          }\n        // }, this.checkDebounceDuration);\n      }\n    };\n\n    this.canvas.addEventListener('mousedown', onMouseDown);\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n\n    // Listeners - touch devices\n    const onTouchStart = (event: TouchEvent) => {\n      window.clearTimeout(prizeTextVisibleCheckTimer);\n      this.canvasTouchStart(event);\n    };\n\n    const onTouchMove = (event: TouchEvent) => {\n      this.canvasTouchMove(event);\n    };\n\n    const onTouchEnd = (event: TouchEvent) => {\n      this.canvasTouchEnd(event);\n      window.clearTimeout(prizeTextVisibleCheckTimer);\n      prizeTextVisibleCheckTimer = window.setTimeout(() => {\n        if (this.isPrizeTextVisible()) {\n          this.showWinningAnimation();\n        }\n      }, this.checkDebounceDuration);\n    };\n\n    this.canvas.addEventListener('touchstart', onTouchStart);\n    this.canvas.addEventListener('touchmove', onTouchMove);\n    this.canvas.addEventListener('touchend', onTouchEnd);\n\n    this.resetButton.addEventListener('click', this.reset.bind(this));\n  }\n}\n\n// Parcel has duplicate events attached when hot reload\n// This workaround is suggested by the official member:\n// https://github.com/parcel-bundler/parcel/issues/1718#issuecomment-404608947\n// @ts-expect-error - `hot` is not defined in node's type definition\nmodule?.hot?.dispose(() => {\n  window.location.reload();\n});\n\nconst LotteryScratchCanvas = new ScratchCanvas(\n  '#scratch-canvas',\n  '#prize-text',\n  '#scratch-reset-button',\n  '#B7B7B7',\n);\n\nLotteryScratchCanvas.init();\n"],"names":["$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","_a","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","adopt","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","Symbol","iterator","n","v","op","TypeError","pop","length","push","ScratchCanvas","canvasSelector","prizeTextSelector","resetButtonSelector","fillColor","isDrawing","checkDebounceDuration","hasWon","canvasElement","document","querySelector","prizeTextElement","resetButtonElement","canvas","prizeText","resetButton","context","getContext","willReadFrequently","canvasWidth","width","canvasHeight","height","removableLayerColor","canvasAnimation","animate","opacity","duration","easing","iterations","fill","cancel","prizeTextAnimation","transform","prototype","getMousePosition","event","rect","getBoundingClientRect","x","clientX","left","clientY","top","getTouchPosition","rootElem","documentElement","pageYOffset","clientTop","pageXOffset","clientLeft","touch","targetTouches","changedTouches","touchX","pageX","touchY","pageY","canvasMouseDown","beginPath","moveTo","canvasMouseMove","lineTo","stroke","canvasMouseUp","canvasTouchStart","preventDefault","canvasTouchMove","canvasTouchEnd","addRemovableLayer","globalCompositeOperation","fillStyle","fillRect","isPrizeTextVisible","prizeTextWidth","clientWidth","prizeTextHeight","clientHeight","pixelData","imageData","getImageData","data","transparentPixelCount","i","red","green","blue","alpha","transparentAreaPercentage","showWinningAnimation","play","reset","_this","lineCap","lineJoin","lineWidth","strokeStyle","prizeTextVisibleCheckTimer","undefined","addEventListener","clearTimeout","setTimeout","bind","hot","dispose","location","reload","LotteryScratchCanvas"],"version":3,"file":"index.df949aa2.js.map"}